# tab页切换的时候发生的代码逻辑
1.tab页切换（页面数据不发生变化，比如tab1:列表页，tab2:点击列表数据进入到编辑页，这时候切换列表页与编辑页，编辑页不会发生数据变化 或者tab1:全部数据，包括所有类别 tab2：一个类别下的数据 这时候切换tab，数据也不会变化） 2.tab页切换（页面数据发生变化，比如tab1:验收，tab2:未审核，这时候切换验收页与未审核页，数据会发生变化，比如用户的操作会导致验收页面增加数据）

页面数据切换没有发生变化，是因为前端做了缓存

前端不需要做缓存机制的情况有以下几种： 1.数据实时性要求高：如果业务需要实时获取最新的数据，并且不能容忍展示过期或不准确的数据，那么不需要进行缓存。每次都直接从后端获取最新数据，确保数据的准确性和实时性。 2.数据更新频率高：如果数据的更新频率非常高，几乎每次请求都会返回不同的数据，那么缓存的效果会较差。在这种情况下，频繁地清空和更新缓存可能会增加系统的复杂性，同时由于缓存数据无法保持最新，可能会导致展示的数据不准确。 3.数据量较小：如果返回的数据量较小，从后端获取数据的成本较低，不会明显影响用户的等待时间和网络性能，那么不需要做缓存机制。每次请求时直接获取数据，避免了缓存带来的管理和同步问题。 4.数据安全性要求高：如果业务中涉及敏感数据或需要保密的信息，前端缓存可能会增加数据泄露的风险。在这种情况下，可以考虑不使用前端缓存或者采用加密等安全机制来保护数据的安全性。

下面是一些常见的前端缓存处理方式： 数据缓存：前端可以将获取到的数据存储在内存中，例如使用变量、数组、对象等数据结构进行存储。这样，在切换回之前已经访问过的tab页时，可以直接使用缓存的数据，而不必重新请求服务器。 页面缓存：前端框架或路由库通常提供了页面缓存的功能。当用户切换到其他tab页时，当前tab页的DOM结构和状态可以被保存在内存中，当再次切换回来时，可以直接还原之前的页面状态，避免重新渲染。 浏览器缓存：前端可以利用浏览器的缓存机制进行数据的存储和管理。通过设置HTTP响应头中的Cache-Control、Expires、Last-Modified等字段，可以控制浏览器缓存数据的有效期和更新机制。这样，在切换tab页时，浏览器可以直接从缓存中加载数据，而不需要重新请求服务器。

用户操作页面后，前端先判断缓存有没有数据，缓存里的数据是不是最新的，有效的，如果是，可以直接使用缓存数据进行展示或操作，如果没有缓存数据，或者缓存数据已经过期或不完整，（先清空缓存）再发出请求（请求新数据前，先清空原有的缓存数据），后端接收到请求，开始处理数据（操作数据库等），操作完后，把数据返回给前端（json等格式），前端接受数据，做数据加工(解析、过滤、排序等操作)，处理后的数据，通过前端模板或者组件渲染出页面的内容，确保用户及时看到页面内容，再根据业务需求和缓存策略，决定是否将数据保存到缓存中。

缓存的合并机制是指将前端缓存数据和后端返回的数据进行合并的方法或策略。具体的合并机制可以根据业务需求和数据结构的特点来确定，常见的合并机制包括以下几种： 1.覆盖合并：将后端返回的数据直接覆盖前端缓存的数据。在每次请求后端数据时，直接使用最新返回的数据替换前端缓存，以保持数据的一致性。 2.增量合并：将后端返回的数据与前端缓存的数据进行比对，将新增或更新的数据合并到前端缓存中。通过比较数据的唯一标识或时间戳等信息，识别出需要更新或添加的数据，避免重复存储或展示。 3.合并展示：将前端缓存数据和后端返回的数据按照一定规则进行合并展示。可以根据数据的优先级、时间顺序等规则进行合并，确保展示的数据既包含了前端缓存的部分历史数据，又包含了后端最新的数据。

缓存合并机制是指在前端接收到后端返回的数据后，将该数据与前端已有的缓存数据进行合并的操作。 在缓存合并机制中，具体的先后顺序可以根据业务需求来确定。一种常见的做法是先展示后端数据，然后将该数据与前端缓存进行合并。这样可以尽快将最新的数据呈现给用户，提供更好的用户体验。 另一种做法是先考虑缓存，将后端返回的数据与前端缓存进行合并，然后再展示合并后的数据。这样可以确保数据在展示之前已经经过缓存的处理和合并，保证数据的准确性和一致性。

造成切换tab页的时候，数据重复显示的原因： 切换tab页的时候，重复请求，每次请求前没有清空缓存，前端在获取后端返回的数据后，将之前的缓存数据与后端返回的数据进行合并操作，导致数据翻倍 修复方法（设置缓存）： 1.重复请求，每次请求前清空缓存，这样每次页面展示后端返回的最新数据，展示数据后更新缓存（频繁地清空和更新缓存可能会增加系统的复杂性） 2.不重复请求，合理运用缓存机制，先在缓存里找数据，没有的话再请求，更新缓存 修复方法（不设置缓存）： 直接使用每次后端返回的数据（最优方法）

在切换tab页时，先清空原有的数据，再发起新的请求，可以确保每次切换都获取到最新的数据，避免数据的重复加载和翻倍现象。 // 当切换到tab1时的处理逻辑 function switchToTab1() { // 清空tab1的数据 clearTab1Data();

// 发起请求获取tab1的数据 fetchDataForTab1();

// 清空tab1的数据 function clearTab1Data() { // 清空tab1相关的数据 // 例如：将tab1的数据列表清空 tab1DataList = []; }

// 发起请求获取tab1的数据 function fetchDataForTab1() { // 发起请求获取tab1的数据 // 例如：调用接口获取tab1的数据 // 将返回的数据存入tab1DataList中 // 刷新tab1的视图 }

视图渲染：前端可能在渲染视图的时候出现了问题，导致页面显示的数据量翻倍，但实际上后端返回的数据并没有重复加载或者缓存。

tab页不清空数据的情况： 在某些场景下，用户可能在当前的tab页面上进行了一些操作或者填写了一些表单数据，但是在切换到其他tab页后又返回到该页面。如果在切换tab页时清空了当前页面的数据，那么用户之前的操作或者输入将会丢失，用户需要重新填写或者重新进行操作，这可能会影响用户体验。 在这种情况下，为了保持用户当前的操作状态，可以选择不清空当前tab页面的数据，而是将数据保留在内存中或者使用前端缓存。这样用户切换回来时，页面上显示的数据仍然保持原样，用户可以继续之前的操作或者查看之前的数据，不需要重新填写或者重新操作。 需要注意的是，在保留数据不清空的情况下，需要确保数据的准确性和一致性。例如，如果其他操作导致数据发生了变动，需要及时更新页面上的显示，或者在用户返回时提示用户数据可能已过期，需要重新加载或者刷新页面。

内存和缓存的区别 内存变量：在前端代码中定义一个变量，用于存储当前tab页面的数据。当切换tab页时，不清空该变量的值，而是保持数据的持久性。在需要使用数据的地方，直接从该变量中读取数据，以实现数据的持久保存。 前端缓存：前端框架或者库通常提供了对数据缓存的支持，例如使用LocalStorage或SessionStorage等。在切换tab页时，将数据存储在缓存中，然后在需要使用数据的地方，先检查缓存中是否存在数据，存在则直接使用缓存中的数据。 数据保存在内存和缓存中有一些区别： 存储位置：数据保存在内存中时，它具有更快的读写速度，但是会随着页面的刷新或关闭而被清空。而数据保存在缓存中时，可以选择将数据存储在浏览器的本地缓存（如LocalStorage或SessionStorage）中，数据在页面刷新或关闭后仍然可以保留。 生命周期：数据保存在内存中的生命周期比较短暂，只在当前页面的生命周期内有效，当页面被关闭或刷新时，数据会被清空。而数据保存在缓存中可以具有更长的生命周期，可以在不同的页面间共享数据，甚至在用户下次访问时仍然存在。 数据容量：内存的容量相对有限，取决于浏览器和设备的内存限制，通常较小。而缓存可以存储更大量级的数据，但是也有一定的限制，通常LocalStorage可以存储更大容量的数据。 数据访问方式：内存中的数据可以直接在代码中访问和操作，速度较快。而缓存中的数据需要通过特定的API进行读取和写入，例如LocalStorage的getItem和setItem方法。

当数据需要在用户的多个页面之间共享时，可以考虑将数据保存在缓存中，例如： 用户登录状态：当用户成功登录后，可以将登录状态保存在缓存中，以便在用户访问其他页面时仍然保持登录状态，避免频繁的登录操作。 用户个性化设置：如果用户有个性化的设置，例如主题颜色、语言偏好等，可以将这些设置保存在缓存中，以便在不同页面间保持用户的个性化体验。 历史浏览记录：如果用户需要查看自己的浏览历史记录，可以将历史记录保存在缓存中，这样用户在不同页面间切换时可以方便地查看之前浏览过的内容。 另一方面，当需要临时存储数据或者数据的生命周期较短时，可以将数据保存在内存中，例如： 表单数据：当用户填写表单时，可以将表单数据保存在内存中，以便在用户提交表单或者刷新页面时保留填写的数据，提供更好的用户体验。 临时计算结果：在某些场景下，需要进行临时的计算操作，计算结果只在当前操作流程中使用，不需要长期保存。这种情况下，可以将计算结果保存在内存中，避免频繁的计算操作。 总之，选择将数据保存在缓存还是内存中，需要根据具体的业务需求和数据的生命周期来决定。缓存适用于需要长期保存和共享的数据，而内存适用于临时性的数据和当前操作的状态保存。